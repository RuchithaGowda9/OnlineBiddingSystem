package com.crimsonlogic.onlinebiddingsystem.serviceimpl;

import com.crimsonlogic.onlinebiddingsystem.dto.UserDto;
import com.crimsonlogic.onlinebiddingsystem.dto.UserInfoDto;
import com.crimsonlogic.onlinebiddingsystem.entity.Role;
import com.crimsonlogic.onlinebiddingsystem.entity.RoleName;
import com.crimsonlogic.onlinebiddingsystem.entity.User;
import com.crimsonlogic.onlinebiddingsystem.entity.UserInfo;
import com.crimsonlogic.onlinebiddingsystem.exception.CustomerAlreadyRegisteredException;
import com.crimsonlogic.onlinebiddingsystem.repository.RoleRepository;
import com.crimsonlogic.onlinebiddingsystem.repository.UserRepository;
import com.crimsonlogic.onlinebiddingsystem.repository.UserInfoRepository;
import com.crimsonlogic.onlinebiddingsystem.service.AuthService;

import java.util.Optional;

import org.modelmapper.ModelMapper;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

@Service
public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final UserInfoRepository userInfoRepository;
    private final RoleRepository roleRepository;
    private final ModelMapper modelMapper;

    // Constructor injection
    public AuthServiceImpl(UserRepository userRepository, UserInfoRepository userInfoRepository, RoleRepository roleRepository, ModelMapper modelMapper) {
        this.userRepository = userRepository;
        this.userInfoRepository = userInfoRepository;
        this.roleRepository = roleRepository;
        this.modelMapper = modelMapper;
    }

    @Transactional
    @Override
    public void register(User user, UserInfo userInfo) {
        if (userRepository.findByEmail(user.getEmail()).isPresent()) {
            throw new CustomerAlreadyRegisteredException("A user with the same email already exists");
        }
        if (userInfoRepository.findByPhoneNumber(userInfo.getPhoneNumber()).isPresent()) {
            throw new CustomerAlreadyRegisteredException("Phone number is already registered: " + userInfo.getPhoneNumber());
        }
        userRepository.save(user);

        userInfo.setUser(user);
        if (userInfo.getRole() != null) {
            Role role = getRoleByName(userInfo.getRole().getName());
            userInfo.setRole(role);
        } else {
            throw new RuntimeException("Role must be provided in UserInfo");
        }

        userInfoRepository.save(userInfo);
    }

  

    @Override
    public String login(UserDto userDto) {
        User user = userRepository.findByEmail(userDto.getEmail())
                .orElseThrow(() -> new RuntimeException("User not found"));
        if (userDto.getPassword().equals(user.getPassword())) {
            UserInfo userInfo = userInfoRepository.findByUser(user)
                    .orElseThrow(() -> new RuntimeException("UserInfo not found"));
            return getDashboardUrlByRole(userInfo.getRole().getRoleId());
        } else {
            throw new RuntimeException("Invalid credentials");
        }
    }

    private String getDashboardUrlByRole(Long roleId) {
        switch (roleId.intValue()) {
            case 1: 
                return "/admin/dashboard";
            case 2: 
                return "/customer/dashboard";
            case 3: 
                return "/delivery/dashboard";
            default:
                throw new RuntimeException("Role not recognized");
        }
    }

    @Override
    public UserInfoDto getUserInfoByEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found"));
        UserInfo userInfo = userInfoRepository.findByUser(user)
                .orElseThrow(() -> new RuntimeException("UserInfo not found"));

        return modelMapper.map(userInfo, UserInfoDto.class);
    }

    private Role getRoleByName(RoleName roleName) {
        return roleRepository.findByName(roleName)
                .orElseThrow(() -> new RuntimeException("Role not found for name: " + roleName));
    }


    @Override
    public boolean validatePassword(String email, String password) {
        // Fetch the user by email
        Optional<User> optionalUser = userRepository.findByEmail(email);
        
        // Check if user is present
        if (!optionalUser.isPresent()) {
            return false; // User not found
        }

        // Get the user and check if the provided password matches the stored password
        User user = optionalUser.get();
        return user.getPassword().equals(password);
    }

    @Override
    public void updatePassword(String email, String newPassword) {
        // Fetch the user by email
        Optional<User> optionalUser = userRepository.findByEmail(email);
        
        // Check if user is present
        if (!optionalUser.isPresent()) {
            throw new RuntimeException("User not found"); // Handle user not found case
        }

        // Get the user
        User user = optionalUser.get();

        // Set the new password
        user.setPassword(newPassword);

        // Save the updated user object to the database
        userRepository.save(user);
    }

}
